---
tags: 程設二 出題助教
---

# 程設二助教出題記錄（2021上半年）

## 13128 - Kuo Wants To Parse 

:::spoiler input and output
> just manually
:::

:::spoiler solution
```cpp=
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

char expr[1000];  // string to store the input expression.
int pos;             // current position of parsing, from end to start

typedef struct _Node {
    int data;
    struct _Node *left, *right;
} BTNode;

BTNode* EXPR();
BTNode* FACTOR();
BTNode* makeNode(int);

void printPrefix(BTNode*);


char res[1000];
int main(void){
    while (scanf("%s", expr)!=EOF)
    {
    	pos = strlen(expr) - 1;
    	for (int i = 0; i <= pos; ++ i) res[i] = expr[i];
    	
		for (int i = 0; i <= pos; ++ i) {
			if (!isdigit(expr[i])) continue;
			int j = i;
			while (isdigit(expr[j])) j += 1;
			j -= 1;
			for (int k = i, ret = j; k <= j; ++ k, -- ret)
				expr[k] = res[ret];
			i = j;
		}
        
        BTNode *root = EXPR();
        printPrefix(root);
        printf("\n");
    }
    return 0;
}

BTNode* EXPR()
{
    BTNode *root = (BTNode*)malloc(sizeof(BTNode));
    if(expr[pos-1]=='(' || pos==0) {
        root = FACTOR();
        pos--;
    }
    else if(expr[pos] == ')' || isdigit(expr[pos])) {
        root->right = FACTOR();
        if(expr[pos]=='+') root->data = -'+';
        else if(expr[pos]=='-') root->data = -'-';
        else {
            pos--;
            return root->right;
        }
        pos--;
        root->left = EXPR();
    }
    return root;
}

BTNode* FACTOR()
{
    BTNode *root;
    if(isdigit(expr[pos])) {
        int res = 0;
        while (pos != -1 && isdigit(expr[pos])) {
        	res = res * 10 + expr[pos] - '0';
        	pos -= 1;
        }
		root = makeNode(res);
    }
    else if(expr[pos]==')') {
        pos--;
        root = EXPR();
    }
    return root;
}
BTNode* makeNode(int c)
{
    BTNode *leave = (BTNode*)malloc(sizeof(BTNode));
    leave->data = c;
    leave->left = NULL;
    leave->right = NULL;
    return leave;
}

/* print a tree by pre-order. */
void printPrefix(BTNode *root){
    if (root != NULL) {
        if (root->data < 0) {
    	    root->data *= -1;
    	    printf("%c ", root->data);
	    }
	    else {
		    printf("%d ", root->data);
	    }
        printPrefix(root->left);
        printPrefix(root->right);
    }
}

```
:::

## 13130 - Kuo Wants Prufer Code

:::spoiler input and output
```cpp=
#include <bits/stdc++.h>
using namespace std;

int n;
vector<int> t;
set<int> s;
multiset<int> tt;

int num[10] = {8, 10, 50, 100, 500, 1000, 5000};

signed main(int argc, char* argv[]) {
    for (int i = 0; i <= 0; ++ i) {
        s.clear();
        t.clear();
        tt.clear();
        int n =  num[i];

        random_device rd;
        default_random_engine gen = default_random_engine(rd());
        uniform_int_distribution<int> dis(1, n);
        auto random = bind(dis, gen);

        for (int i = 1; i <= n - 2; ++i) t.push_back(random() % n + 1);
        for (int i = 1; i <= n; ++i) s.insert(i);

        ofstream input(to_string(i) + ".out");
        for (auto i:t) input << i << " "; input << endl;
        input.close();

        for (auto i:t) {
            if (s.find(i) != s.end()) s.erase(s.find(i));
            tt.insert(i);
        }

        ofstream output(to_string(i) + ".in");
        output << n << endl;
        for (auto i:t) {
            auto it = s.begin();
            output << *it << " " << i << endl;
            s.erase(it);
            tt.erase(tt.find(i));
            if (tt.find(i) == tt.end())
                s.insert(i); 
        }

        output << *s.begin() << " " << *s.rbegin() << endl;
        output.close();
    }
}

```
:::

:::spoiler solution
```cpp=
#include <bits/stdc++.h>
using namespace std;

#define sz(v) (int)(v).size()

int n;
set<int> s[5009];

signed main() {
    cin >> n;
    for (int i = 1; i <= n - 1; ++ i) {
        int a, b;
        cin >> a >> b;
        s[a].insert(b);
        s[b].insert(a);
    }

    set<int> t;
    for (int i = 1; i <= n; ++ i) 
        if (sz(s[i]) == 1)
            t.insert(i);

    for (int _ = 1; _ <= n - 2; ++ _) {
        int res = *t.begin();
        cout << *s[res].begin() << " ";
        s[*s[res].begin()].erase(res);
        t.erase(res);
        if (sz(s[*s[res].begin()]) == 1) t.insert(*s[res].begin());
    }
    cout << endl;
}
```
:::

## 13132 - KuoYangてぇてぇ — Birthday Present

:::spoiler input
```cpp=
#include <bits/stdc++.h>
using namespace std;

#define IOS ios::sync_with_stdio(0); cin.tie(0);
#define endl '\n'

int input_num[10] = {20, 1000, 1000, 1000, 100000, 100000, 100000};
vector<int> random_op;

signed main() { IOS
	srand(time(NULL));
	for (int _ = 0; _ <= 6; ++ _) {
		random_device rd;
		default_random_engine gen = default_random_engine(rd());
		uniform_int_distribution<int> dis(1, input_num[_]);
		auto random = bind(dis, gen);
		
		int n = input_num[_], q = input_num[_] * 2, k = random();
		if (_ == 1 || _ == 4) q = n - 10;
		
		if (_ == 0 || _ == 3 || _ == 6) {
			for (int i = 1; i <= q / 10; ++ i) random_op.push_back(0);
			int res = q - q / 10;
			int x = (res - n / 2) / 2;
			int y = (res + n / 2) / 2;
			for (int i = 1; i <= x; ++ i) random_op.push_back(random());
			for (int i = 1; i <= y; ++ i) random_op.push_back(-random());
			random_shuffle(random_op.begin(), random_op.end());
			random_shuffle(random_op.begin(), random_op.end());
			random_shuffle(random_op.begin(), random_op.end());
			random_shuffle(random_op.begin(), random_op.end());
		}
		
		if (_ == 2 || _ == 5) {
			int x = (q - n / 2) / 2;
			int y = (q + n / 2) / 2;
			for (int i = 1; i <= x; ++ i) random_op.push_back(random());
			for (int i = 1; i <= y; ++ i) random_op.push_back(-random());
			random_shuffle(random_op.begin(), random_op.end());
			random_shuffle(random_op.begin(), random_op.end());
			random_shuffle(random_op.begin(), random_op.end());
			random_shuffle(random_op.begin(), random_op.end());
		}
		
		ofstream input(to_string(_) + ".in");
		input << n << " " << k << " " << q << endl;
		for (int i = 1; i <= n; ++ i) input << random() << " \n"[i == n];
		
		while ( q -- ) {
			if (_ == 1 || _ == 4) {
				input << "pop" << endl;
			}
			else if (_ == 2 || _ == 5) {
				if (random_op.back() > 0) input << "push " << random() << endl;
				else if (random_op.back() < 0) input << "pop" << endl;
				random_op.pop_back();
			}
			else if (_ == 3 || _ == 6 || _ == 0) {
				if (random_op.back() > 0) input << "push " << random() << endl;
				else if (random_op.back() < 0) input << "pop" << endl;
				else if (random_op.back() == 0) input << "programming tanoshi" << endl;
				random_op.pop_back();
			}
		}
		input.close();
	}
}
```
:::

:::spoiler output
```cpp=
#include <bits/stdc++.h>
using namespace std;

#define IOS ios::sync_with_stdio(0); cin.tie(0);
#define endl '\n'

int n, k, q;
int val[250009];
int tag[250009];
int nxt[250009];
int pre[250009];

int main() { IOS
	for (int _ = 0; _ <= 6; ++ _) {
		ifstream input(to_string(_) + ".in");
		
		memset(val, 0, sizeof(val));
		memset(tag, 0, sizeof(tag));
		memset(nxt, 0, sizeof(nxt));
		memset(pre, 0, sizeof(pre));
		
		input >> n >> k >> q;
		for (int i = 1; i <= n; ++ i) {
			input >> val[i];
			nxt[i] = i + 1;
			pre[i] = i - 1;
		}
		pre[1] = 0;
		
		int mid = (n + 1) / 2, sz = n;
		
		while ( q -- ) {
			string op; input >> op;
			if (op == "push") {
				input >> val[n + 1];
				nxt[n + 1] = n + 2;
				pre[n + 1] = n;
				
				n += 1;
				sz += 1;
				if (sz % 2 == 1) mid = nxt[mid];
			}
			else if (op == "pop") {
				nxt[pre[mid]] = nxt[mid];
				pre[nxt[mid]] = pre[mid];
				val[mid] = 0;
				tag[pre[mid]] += tag[mid];
				sz -= 1;
				if (sz % 2 == 0) mid = pre[mid];
				else mid = nxt[mid];
			}
			else if (op == "programming") {
				input >> op;
				tag[n] += 1;
			}
		}
		input.close();
		
		int now = n;
		bool flag = false;
		
		while (1) {
			if (tag[now]) flag = true;
			if (flag) val[now] %= k;
			if (pre[now] != 0) now = pre[now];
			else break;
		}
		
		ofstream output(to_string(_) + ".out");
		while (nxt[now] != 0) {
			output << val[now] << " ";
			now = nxt[now];
		}
		output << endl;
		output.close();
	}
}
```
:::

:::spoiler solution (partial)
```cpp=
#ifndef FUNCTION_H
#define FUNCTION_H

#include <stdlib.h>

typedef struct _Node{
    struct _Node *prev;
    struct _Node *next;
    int val;
    int tag;
}Node;

int n, k, q;
Node *head;
Node *tail;
Node *mid;
int sz;

void push(int x) {
	if (head == NULL) {
		head = malloc(sizeof(Node));
		head->prev = NULL;
		head->val = x;
		head->tag = 0;
		tail = head;
		sz += 1;
		mid = head;
	}
	else {
		tail->next = malloc(sizeof(Node));
		tail->next->prev = tail;
		tail = tail->next;
		
		tail->val = x;
		tail->tag = 0;
		tail->next = NULL;
		
		sz += 1;
		if (sz % 2 == 1) mid = mid->next;
	}
}

void pop() {
    if (sz == 1) {
        sz = 0;
        head = mid = tail = NULL;
        return;
    }
    if (sz == 2) {
        tail->prev = NULL;
        head = mid = tail;
        return;
    }
	mid->prev->next = mid->next;
	mid->next->prev = mid->prev;
	if (mid->tag) mid->prev->tag = 1;
	sz -= 1;
	if (sz % 2 == 0) mid = mid->prev;
	else mid = mid->next;
}

void programming_tanoshi() {
	tail->tag = 1;
}

void KuoYangTeTe() {
	int flag = 0;
	while (tail != NULL) {
		if (tail->tag == 1) flag = 1;
		if (flag == 1) tail->val %= k;
		tail = tail->prev;
	}
}

#endif
```
:::

## 13141 - KuoYangてぇてぇ — Birthday Gift

:::spoiler input and output
```cpp=
#include <bits/stdc++.h>
#include "meow.h"
using namespace std;

#define int long long

int input_num[10] = {10, 2000, 2000, 2000, 300000, 300000, 300000, 300000, 300000};
set<int> ban[10];

signed main() {
	ban[0] = {1, 2, 3, 4};
	ban[1] = {1, 2};
	ban[2] = {1, 2, 3};
	ban[3] = {1, 2, 3, 4};
	ban[4] = {1, 2};
	ban[5] = {1, 2, 3};
	ban[6] = {1, 2, 4};
	ban[7] = {1, 2, 3, 4};
	ban[8] = {1, 2, 3, 4};
	
	ios::sync_with_stdio(0); cin.tie(0);
	srand(time(NULL));
	
	vector<int> res({1, 3, 4, 1, 3, 4, 3, 2, 2, 2});
	vector<int> temp({1, 1, 1, 1, 1, 2, 2, 2, 3, 4});
	
	for (int _ = 0; _ <= 8; ++ _) {
		cout << "input " << _ << endl;
		random_device rd;
		default_random_engine gen = default_random_engine(rd());
		uniform_int_distribution<int> dis(1, 1000000000);
		auto random = bind(dis, gen);
		
		ofstream input(to_string(_) + ".in");
		
		auto op = [&](int x) -> void {
			if (ban[_].find(x) == ban[_].end()) x = 1;
			if (x == 1) {
				input << "PUSH " << random() << endl;
			}
			else if (x == 2) {
				input << "POP" << endl;
			}
			else if (x == 3) {
				if (_ != 8) input << "PROGRAMMING TANOSHI " << random() % 9 + 1 << endl;
				else input << "PROGRAMMING TANOSHI " << 1 << endl;
			}
			else if (x == 4) {
				input << "IP2 SUGOI" << endl;
			}
		};
		
		int q = (input_num[_] - (int)res.size()) / (int)temp.size();
		
		for (auto i : res) op(i);
		while (q--) {
			random_shuffle(temp.begin(), temp.end());
			if (q % 100 != 0) {
				for (auto i : temp) {
					if (i == 4) op(3);
					else op(i); 
				}
			}
			else {
				for (auto i : temp) {
					if (i == 3) op(4);
					else op(i);
				}
			}
			
		}
		
		input.close();
	}
	
	for (int _ = 0; _ <= 8; ++ _) {
		cout << "output " << _ << endl;
		init();
		
		ifstream input(to_string(_) + ".in");
		while (input_num[_] --) {
			string op;
			input >> op;
			
			if (op[1] == 'U') {
				int x; 
				input >> x;
				push(x);
			}
			else if (op[1] == 'O') {
				pop();
			}
			else if (op[1] == 'R') {
				int k;
				input >> op >> k;
				tanoshi(k);
			}
			else if (op[1] == 'P') {
				input >> op;
				sugoi();
			}
		}
		input.close();

		tete();
		ofstream output(to_string(_) + ".out");
		while (head) {
			output << head->val << " ";
			head = head->next;
		}
		output << endl;
		output.close();
	}
}
```
:::

:::spoiler solution (partial)
```cpp=
#ifndef FUNCTION_H
#define FUNCTION_H

#include <stdlib.h>
#include <math.h>
#include <limits.h>

#define int long long

typedef struct _Node{
    struct _Node *prev;
    struct _Node *next;
    int val;
    int tag[30];
    int tag_length;
}Node;

Node *head, *mid, *tail;
int sz;
int res[100000];
int res_length = 0;

void push(int x) {
	if (head == NULL) {
		head = malloc(sizeof(Node));
		head->prev = NULL;
		head->val = x;
		head->tag_length = 0;
		tail = head;
		sz += 1;
		mid = head;
	}
	else {
		tail->next = malloc(sizeof(Node));
		tail->next->prev = tail;
		tail = tail->next;
		
		tail->val = x;
		tail->next = NULL;
		tail->tag_length = 0;
		
		sz += 1;
		if (sz % 2 == 1) mid = mid->next;
	}
}

void pop() {
    if (sz <= 1) {
        sz = 0;
        head = mid = tail = NULL;
        return;
    }
    if (sz == 2) {
    	tail->prev = NULL;
		head = mid = tail;
    	sz = 1;
    	return;
	}
	mid->prev->next = mid->next;
	mid->next->prev = mid->prev;
	if (mid->tag_length != 0) {
		for (int i = 0; i < mid->tag_length; ++ i) {
			mid->prev->tag[mid->prev->tag_length] = mid->tag[i];
			mid->prev->tag_length += 1;
		}
	}
	sz -= 1;
	if (sz % 2 == 0) mid = mid->prev;
	else mid = mid->next;
}

void programming_tanoshi(int k) {
	if (tail == NULL) return;
	tail->tag[tail->tag_length] = k;
	tail->tag_length += 1;
}

void IP2_sugoi() {
	if (tail == NULL) return;
	tail->tag[tail->tag_length] = -1;
	tail->tag_length += 1;
}

int squareroot(int x) {
	int y = sqrt(x);
	while (x < y * y) y -= 1;
	while ((y + 1) * (y + 1) <= x) y += 1;
	return y;
}

int proc(int x) {
	for (int i = res_length - 1; i >= 0; -- i) {
		if (res[i] == -1) x = squareroot(x);
		else x = x / res[i] + (x % res[i] != 0);
	}
	return x;
}

void KuoYangTeTe() {
	int cnt = 0;
	
	while (tail) {
		if (cnt >= 5) {
			tail->val = 1;
			tail = tail->prev;
			continue;
		}
		
		while (tail->tag_length != 0) {
			if (tail->tag[tail->tag_length - 1] == -1) cnt += 1;
			
			if (res_length != 0 && res[res_length - 1] != -1 && tail->tag[tail->tag_length - 1] != -1) {
				res[res_length - 1] *= tail->tag[tail->tag_length - 1];
				if (res[res_length - 1] > INT_MAX) res[res_length - 1] = (long long)INT_MAX + 1LL;
			}
			else {
				res[res_length] = tail->tag[tail->tag_length - 1];
				res_length += 1;
			}
			tail->tag_length -= 1;
		}
		
		tail->val = proc(tail->val);
		tail = tail->prev;
	}
}

#endif
```
:::

:::spoiler check
```cpp=
#include <bits/stdc++.h>
using namespace std;

#define int long long

struct Node{
	int val;
	Node *prev, *next;
};

int q;

int squareroot(int x) {
	int y = sqrt(x);
	while (x < y * y) y -= 1;
	while ((y + 1) * (y + 1) <= x) y += 1;
	return y;
}

signed main() {
	for (int _ = 0; _ <= 8; ++ _) {
		cout << "Check " << _ << endl;
		Node *head, *tail;
		int sz = 0;
		
		ifstream input(to_string(_) + ".in");
		string op;
		while (input >> op) {
			if (op[1] == 'U') {
				int x; input >> x;
				if (head == NULL) {
					head = new Node();
					head->prev = NULL;
					head->val = x;
					tail = head;
				}
				else {
					tail->next = new Node();
					tail->next->prev = tail;
					tail = tail->next;
					
					tail->val = x;
					tail->next = NULL;
				}
				sz += 1;
			}
			else if (op[1] == 'O') {
				if (sz == 0) continue;
				else if (sz == 1) {
					head = tail = NULL;
				}
				else if (sz == 2) {
					tail->prev = NULL;
					head = tail;
				}
				else {
					int mid = (sz + 1) / 2;
					Node *res = head;
					for (int i = 1; i < mid; ++ i) {
						res = res->next;
					}
					res->prev->next = res->next;
					res->next->prev = res->prev;
				}
				sz -= 1;
			}
			else if (op[1] == 'R') {
				int k; input >> op >> k;
				Node *res = head;
				while (res) {
					res->val = res->val / k + (res->val % k != 0);
					res = res->next;
				}
			}
			else if (op[1] == 'P') {
				input >> op;
				Node *res = head;
				while (res) {
					res->val = squareroot(res->val);
					res = res->next;
				}
			}
		}
		input.close();
		
		ifstream output(to_string(_) + ".out");
		vector<int> v;
		while (head) {
			v.push_back(head->val);
			head = head->next;
		}
		
		int ret;
		vector<int> u;
		while (output >> ret) u.push_back(ret);
		
		if (v.size() != u.size()) {
			cout << "length wrong " << _ << endl;
		}
		for (int i = 0; i < u.size(); ++ i) {
			if (v[i] != u[i]) {
				cout << "value wrong " << _ << " " << i << endl;
				cout << u[i] << " " << v[i] << endl;
			}
		}
		output.close();
	}
}
```
:::

## 	13161 - Kuo Sends Names To Mars

:::spoiler input and output
LOST QQ
:::

:::spoiler solution
```cpp=
#include <iostream>

using namespace std;

int main() {
    string str;
    cin >> str;
    int cnt = 0;

    for (int i=1; i<str.size(); i++) {
        if (str[i-1] == str[i] && str[i] == str[i+1] && str[i] != '#') {
            cnt += 2;
            str[i] = str[i+1] = '#';
        }
        else if (str[i-1] == str[i+1] && str[i+1] != '#') {
            cnt++;
            str[i+1] = '#';
        }
        else if (str[i-1] == str[i] && str[i] != '#') {
            cnt++;
            str[i] = '#';
        }
    }

    cout << cnt << endl;
}
```
:::


## 13182 - Twenty One 
:::spoiler input and output
```cpp=
#include <bits/stdc++.h>
#define debug(a) cout << #a << " = " << a << endl;
using namespace std;

int N[7] = {2, 1000, 1000, 1000, 1000, 1000, 1000};
int Q[7] = {3, 100, 100, 100, 100, 100, 100};

vector<string> name;

signed main() {
	set<string> res;
	while (name.size() <= 300) {
		string s;
		while (s.size() < 3) {
			s.push_back('a' + rand() % 26);
		}
		if (res.find(s) != res.end()) 
			continue;
		else {
			res.insert(s);
			name.push_back(s);
		}
	}
	
	for (int _ = 0; _ <= 0; ++ _) {
		debug(_)
		ofstream input(to_string(_) + ".in");
		
		if (_ == 0) {
			input << N[_] << endl;
			input << "Casino " << Q[_] << " 1000" << endl;
			input << "Guest Kuo 1000 20000" << endl;
			input << "Win Kuo 100000" << endl;
			input << "Guest Kuo 30 15" << endl;
			input << "Casino " << Q[_] << " 30" << endl;
			input << "Guest Yang 1000 30" << endl;
			input << "Win Kuo 1000" << endl;
			input << "Win Yang 100000" << endl;
			input.close();
			continue;
		}
		
		input << N[_] << endl;
		while ( N[_] -- ) {
			input << "Casino " << Q[_] << " " << rand() % 10000 << endl;
			
			vector<string> people;
			for (int __ = 0; __ < Q[_]; ++ __) {
				int op = rand() % 3;
				int id = rand() % 300;
				
				int neg = rand() % 200;
				if (neg <= 130) neg = 1;
				else neg = -1;

				if (op == 0) {
					input << "Guest " << name[id] << " " << rand() % 1000000 << " " << rand() % 100000 << endl;
					people.push_back(name[id]);
				}
				else if (op == 1 && people.size() != 0) {
					int kd = rand() % (people.size());
					input << "Win " << people[kd] << " " << neg * rand() % 30000 << endl;
				}
				else {
					input << "Win " << name[id] << " " << neg * rand() % 100000 << endl;
				}
			}
		}
		
		input.close();
	}
	
	for (int _ = 0; _ <= 6; ++ _) {
		debug(_)
		ifstream input(to_string(_) + ".in");
		
		int n, fee, q;
		string op;
		
		int income = 0;
		vector<string> black;
		
		map<string, int> skill;
		map<string, int> money;
		set<string> list;
		set<string> casino;
		
		auto blacklist = [&](string s) -> void {
			if (casino.find(s) != casino.end())
				casino.erase(s);
			black.push_back(s);
			list.insert(s);
		};
		
		input >> n;
		while ( n -- ) {
			input >> op >> q >> fee;
			
			while ( q -- ) {
				input >> op;
				if (op == "Guest") {
					string s; int m, ski;
					input >> s >> m >> ski;
					if (list.find(s) != list.end()|| casino.find(s) != casino.end())
						continue;
					else if (m <= fee) {
						income += m;
						blacklist(s);
					}
					else {
						income += fee;
						money[s] = m - fee;
						skill[s] = ski;
						casino.insert(s);
					}
				}
				else if (op == "Win") {
					string s; int m;
					input >> s >> m;
					if (casino.find(s) == casino.end() || list.find(s) != list.end())
						continue;
					else if (m + money[s] <= 0) {
						income += money[s];
						blacklist(s);
					}
					else if (skill[s] * 2 < m) {
						income -= m;
						blacklist(s);
					}
					else {
						money[s] += m;
						income -= m;
					}
				}
			}
			money.clear();
			skill.clear();
			casino.clear();
		}
		input.close();
		ofstream output(to_string(_) + ".out");
		output << income << endl;
		for (auto i : black)
			output << i << endl;
		debug(income)
	}
}
```
:::

::: spoiler main.cpp
```cpp=
#include <iostream>
#include <string>
#include "function.cpp"
#include <bits/stdc++.h>
using namespace std;

int n;
Casino casino = {};

int main() {
	cin >> n;
	for (int i = 0; i < n; ++ i) {
		string op;
		int q, fee;
		
		cin >> op >> q >> fee;
		casino.Enterance(fee);
		for (int j = 0; j < q; ++ j) {
			cin >> op;
			if (op == "Guest") {
				string name; 
				int money, skill;
				cin >> name >> money >> skill;
				casino.GuestEnter(name, money, skill);
			} 
			else if (op == "Win") {
				string name;
				int money;
				cin >> name >> money;
				casino.Win(name, money);
			}
		}
		casino.EndDay();
	}
	casino.Result();
}
```
:::

:::spoiler function.h
```cpp=
#include <string>
using namespace std;

class Guest {
public:
	Guest();
	Guest(string s, int m, int ski);
	~Guest();
	string get_name();
	int get_money();
	int get_skill();
	void Win(int m);
	
private:
	string name;
	int money;
	int skill;
};

class Casino {
public:
	Casino();
	~Casino();
	void Enterance(int f);
	void GuestEnter(string s, int m, int ski);
	void Win(string s, int m);
	void EndDay();
	void Result();
	
private:
	int fee;
	
	int guest_num;
	Guest guest[1009];
	
	int income;
	int list_num;
	string blacklist[1009];
};
```
:::

::: spoiler solution
```cpp=
#include "function.h"
#include <bits/stdc++.h>
using namespace std;

Guest::Guest() {}
Guest::Guest(string s, int m, int ski) {
	name = s;
	money = m;
	skill = ski;
}
string Guest::get_name() {
	return name;
}
int Guest::get_money() {
	return money;
}
int Guest::get_skill() {
	return skill;
}
void Guest::Win(int m) {
	money += m;
}
Guest::~Guest() {}

Casino::Casino() {
	guest_num = 0;
	list_num = 0;
}
void Casino::Enterance(int f) {
	fee = f;
}
void Casino::GuestEnter(string s, int m, int ski) {
	for (int i = 0; i < list_num; ++ i)
		if (blacklist[i] == s)
			return;
	for (int i = 0; i < guest_num; ++ i)
		if (guest[i].get_name() == s)
			return;
	
	if (m <= fee) {
		income += m;
		blacklist[list_num ++] = s;
	}
	else {
		income += fee;
		guest[guest_num ++] = Guest(s, m - fee, ski);
	}
}
void Casino::Win(string s, int m) {
	for (int i = 0; i < list_num; ++ i)
		if (blacklist[i] == s)
			return;
	
	int id;
	for (id = 0; id < guest_num; ++ id)
		if (guest[id].get_name() == s)
			break;
	if (id == guest_num)
		return;

	if (guest[id].get_money() + m <= 0) {
		income += guest[id].get_money();
		blacklist[list_num ++] = s;
	}
	else if (guest[id].get_skill() * 2 < m) {
		income -= m;
		blacklist[list_num ++] = s;
	}
	else {
		income -= m;
		guest[id].Win(m);
	}
}
void Casino::EndDay() {
	guest_num = 0;
}
void Casino::Result() {
	cout << income << endl;
	for (int i = 0; i < list_num; ++ i)
		cout << blacklist[i] << endl;
}
Casino::~Casino() {}
```
:::

## 13203 - Twenty One - Guard, Banker, and Players

:::spoiler input and output
```cpp=
#include <bits/stdc++.h>
#define debug(a) cout << #a << " = " << a << endl;
using namespace std;

int N[7] = {3, 100, 100, 100, 500, 500, 500};
int K[7] = {1, 100, 100, 100, 500, 500, 500};

vector<string> GenerateName(int);
vector<int> GenerateCard();

signed main() {
	for (int _ = 0; _ <= -1; ++ _) {
		debug(_)
		ofstream input(to_string(_) + ".in");
		
		if (_ == 0) {
			input << "9999 299" << endl; // guardskill bankerskill
			input << "4" << endl; // guests
			input << "Kuo 1000 10" << endl; // name money skill
			input << "Yang 100 300" << endl;
			input << "Elite 10 100" << endl;
			input << "Miko 10 10000" << endl;
			input << "1" << endl; // rounds
			input << "Kuo 1000" << endl; // name betmoney
			input << "10 9" << endl; // cards
			input << "Yang 50" << endl;
			input << "11 10" << endl;
			input << "Elite 10000" << endl;
			input << "1 1 1 1 2 2 2 2 3 3 3 3" << endl;
			input << "Miko 20000" << endl;
			input << "4 4 4 4 6" << endl;
			input << "9 9" << endl; // banker cards
			input.close();
			continue;
		}
		
		vector<string> names = GenerateName(N[_]);

		input << rand() << " " << rand() << endl;
		input << N[_] << endl;
		for (auto i : names)
			input << i << " " << rand() << " " << rand() << endl;
		input << K[_] << endl;
		while (K[_] --) {
			for (auto i : names) {
				input << i << " " << (int)(rand() / 1.5) << endl;
				vector<int> cards = GenerateCard();
				for (auto j : cards)
					input << j << " ";
				input << endl;
			}
			vector<int> cards = GenerateCard();
			for (auto i : cards)
				input << i << " ";
			input << endl;
		}
		input.close();
	}
	
	for (int _ = 0; _ <= 0; ++ _) {
		debug(_)
		ifstream input (to_string(_) + ".in");
		ofstream output (to_string(_) + ".out");
		
		#define F first
		#define S second
		
		pair<int, int> guard = {0, 0}, banker = {0, 0};
		int n, k;
		string name[1009];
		pair<int, int> player[1009];
		pair<int, int> bet[1009];
		bool invalid[1009] = {};
		
		input >> guard.S >> banker.S >> n;
		for (int i = 1; i <= n; ++ i)
			input >> name[i] >> player[i].F >> player[i].S;
		
		input >> k;
		while (k --) {
			for (int i = 1; i <= n; ++ i) {
				string a; bet[i].S = 0; 
				input >> a >> bet[i].F;
				string res = "";
				while (res.size() <= 0) 
					getline(input, res);
				stringstream ss(res);
				while (ss >> res) {
					int temp = 0;
					for (auto i : res)
						temp = temp * 10 + i - '0';
					bet[i].S += temp;
				}
			}

			int banker_card = 0;
			string res = "";
			while (res.size() <= 0)
				getline(input, res);
			stringstream ss(res);
			while (ss >> res) {
				int temp = 0;
				for (auto i : res)
					temp = temp * 10 + i - '0';
				banker_card += temp;
			}
			
			for (int i = 1; i <= n; ++ i) {
				if (invalid[i] == true)
					continue;
				if (bet[i].S <= 21 && (banker_card > 21 || bet[i].S > banker_card)) {
					int x = bet[i].F + (player[i].S < banker.S) * 10 * bet[i].S;
					if (bet[i].S == 21) x *= 2;
					player[i].F += x;
					banker.F -= x;
					
					if (player[i].S * 2 < x) {
						banker.F -= 100;
						guard.F += 100;
						if (player[i].S > guard.S) {
							guard.F -= player[i].S - guard.S;
							player[i].F += player[i].S - guard.S;
						}
						invalid[i] = true;
					}
				}
				else if (banker_card <= 21 && (bet[i].S > 21 || banker_card >= bet[i].S)) {
					banker.F += min(player[i].F, bet[i].F);
					player[i].F -= min(player[i].F, bet[i].F);
					
					
					if (player[i].F <= 0) {
						banker.F -= 100;
						guard.F += 100;
						invalid[i] = true;
					}
				}
			}
		}
		
		output << guard.F << " " << banker.F << endl;
		for (int i = 1; i <= n; ++ i)
			output << name[i] << " " << player[i].F << endl;
		
		input.close();
		output.close();
	}
	
	for (int _ = 0; _ <= 6; ++ _) {
		ifstream output(to_string(_) + ".out");
		int a, b;
		output >> a >> b;
		int sum = a + b;
		string s;
		while (output >> s >> a) {
			sum += a;
		}
		output.close();
		
		ifstream input(to_string(_) + ".in");
		input >> a >> b;
		int n; input >> n;
		while (n--) {
			string a; int b, c;
			input >> a >> b >> c;
			sum -= b;
		}
		debug(sum)
		input.close();
	}
}

vector<string> GenerateName(int num) {
	set<string> res;
	while (res.size() < num) {
		string s = "";
		while (s.size() < 4) 
			s.push_back(rand() % 26 + 'a');
		res.insert(s);
	}
	return vector<string> (res.begin(), res.end());
}

vector<int> GenerateCard() {
	vector<int> res;
	int sum = 0;
	do {
		int a = rand() % 10 + 1;
		res.push_back(a);
		sum += res.back();
	}while (rand() % 4 != 0 && sum < 21);
	return res;
}
```
:::

:::spoiler main.cpp
```cpp=
#include <iostream>
#include <cstring>
#include "function.h"
using namespace std;

signed main() {
	int guard_skill, banker_skill;
	cin >> guard_skill >> banker_skill;
	Human *guard = new Guard(guard_skill);
	Human *banker = new Banker(banker_skill);

	Human *player[1009];
	int n;
	cin >> n;
	for (int i = 1; i <= n; ++ i) {
		string name;
		int player_money, player_skill;
		cin >> name >> player_money >> player_skill;
		player[i] = new Player(name, player_money, player_skill);
	}

	int k;
	cin >> k;
	while (k--) {
		for (int i = 1; i <= n; ++ i) {
			player[i]->Bet();
			player[i]->Draw();
		}
		banker->Draw();
	
		for (int i = 1; i <= n; ++ i) {
			if (player[i]->Kicked())
				continue;
			
			if (banker->Win(player[i]) == 1) {
				player[i]->Pay(banker);
				if (player[i]->Bankrupt()) {
					banker->Pay(guard);
					guard->Kick(player[i], 0);
				}
			}
			else if (banker->Win(player[i]) == 0) {
				banker->Pay(player[i]);
				if (player[i]->Cheat(banker)) {
					banker->Pay(guard);
					guard->Kick(player[i], 1);
				}
			} // otherwise draw
		}
	}
	
	cout << guard->get_money() << " " << banker->get_money() << endl;
	for (int i = 1; i <= n; ++ i)
		cout << player[i]->name << " " << player[i]->get_money() << endl;
	
}
```
:::

:::spoiler function.h
```cpp=
#include <string>
using namespace std;

class Human {
public:
	string name;
	int money;
	int skill;
	bool kicked;
	int cards;
	int bets;

	Human(string n, int m, int ski);
	
	virtual void Pay(Human *human) = 0;
	virtual void Bet() {}
	virtual void Draw() {}
	virtual bool Kicked() {}
	virtual int Win(Human *human) {}
	virtual bool Bankrupt() {}
	virtual void Kick(Human *human, int flag) {}
	virtual bool Cheat(Human *human) {}
	int get_money();
	~Human();
};

class Guard : public virtual Human {
public:
	Guard(int ski);
	void Pay(Human *human);
	void Kick(Human *human, int flag);
};

class Banker : public virtual Human {
public:
	Banker(int ski);
	void Pay(Human *human);
	int Win(Human *human);
	void Draw();
	~Banker();
};

class Player : public virtual Human {
public:
	Player(string name, int m, int ski);
	void Pay(Human *human);
	void Bet();
	void Draw();
	bool Kicked();
	bool Bankrupt();
	bool Cheat(Human *human);
	~Player();
};
```
:::

:::spoiler solution
```cpp=
#include <bits/stdc++.h>
using namespace std;

class Human {
public:
	string name;
	int money;
	int skill;
	bool kicked;
	int cards;
	int bets;

	Human(string n, int m, int ski);
	
	virtual void Pay(Human *human) = 0;
	virtual void Bet() {}
	virtual void Draw() {}
	virtual bool Kicked() {}
	virtual int Win(Human *human) {}
	virtual bool Bankrupt() {}
	virtual void Kick(Human *human, int flag) {}
	virtual bool Cheat(Human *human) {}
	int get_money();
	~Human();
};

/////////////////////////////////////////////

class Guard : public virtual Human {
public:
	Guard(int ski);
	void Pay(Human *human);
	void Kick(Human *human, int flag);
};

/////////////////////////////////////////////

class Banker : public virtual Human {
public:
	Banker(int ski);
	void Pay(Human *human);
	int Win(Human *human);
	void Draw();
	~Banker();
};

/////////////////////////////////////////////

class Player : public virtual Human {
public:
	Player(string name, int m, int ski);
	void Pay(Human *human);
	void Bet();
	void Draw();
	bool Kicked();
	bool Bankrupt();
	bool Cheat(Human *human);
	~Player();
};

/////////////////////////////////////////////

Human::Human(string n, int m, int ski) {
	name = n;
	money = m;
	skill = ski;
	
	kicked = false;
	cards = 0;
}

int Human::get_money() {
	return this->money;
}

/////////////////////////////////////////////

Guard::Guard(int ski) : Human("guard", 0, ski) {}
void Guard::Pay(Human *human) {
	human->money += human->skill - this->skill;
	this->money -= human->skill - this->skill;
}
void Guard::Kick(Human *human, int flag) {
	if (flag == 1 && this->skill < human->skill) {
		Pay(human);
	}
	human->kicked = true;
}

/////////////////////////////////////////////

Banker::Banker(int ski) : Human("banker", 0, ski) {}
void Banker::Pay(Human *human) {
	if (human->name == "guard") {
		human->money += 100;
		this->money -= 100;
	}
	else {
		int x = (human->bets + (human->skill < this->skill) * human->cards * 10) * (1 + (human->cards == 21));
		human->money += x;
		this->money -= x;
	}
}
int Banker::Win(Human *human) {
	if (this->cards > 21 && human->cards > 21)
		return 2;
	if (this->cards <= 21 && (human->cards > 21 || human->cards <= this->cards))
		return 1;
	return 0;
}
void Banker::Draw() {
	this->cards = 0;
	
	string res = "";
	while (res.size() <= 0)
		getline(cin, res);
	stringstream ss(res);
	
	while (ss >> res) {
		int temp = 0;
		for (auto i : res)
			temp = temp * 10 + i - '0';
		this->cards += temp;
	}
}

/////////////////////////////////////////////

Player::Player(string name, int m, int ski) : Human(name, m, ski) {}
void Player::Pay(Human *human) {
	human->money += min(this->bets, this->money);
	this->money -= min(this->bets, this->money);
}
void Player::Bet() {
	string a;
	cin >> a >> this->bets;
}
void Player::Draw() {
	this->cards = 0;
		
	string res = "";
	while (res.size() <= 0)
		getline(cin, res);
	stringstream ss(res);
	
	while (ss >> res) {
		int temp = 0;
		for (auto i : res)
			temp = temp * 10 + i - '0';
		this->cards += temp;
	}
}
bool Player::Kicked() {
	return this->kicked;
}
bool Player::Bankrupt() {
	return (this->money <= 0);
}
bool Player::Cheat(Human *human) {
	int x = (this->bets + (this->skill < human->skill) * this->cards * 10) * (1 + (this->cards == 21));
	return (this->skill * 2 < x);
}
```
:::

## 13208 - Twenty One - Extreme 

:::spoiler input and output
```cpp=
#include <bits/stdc++.h>
#define debug(a) cout << #a << " = " << a << endl;
using namespace std;

int N[25] = {2, 100, 100, 100, 100, 100, 1, 1, 1, 1, 1, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100};
int Q[25] = {3, 100, 100, 100, 100, 100, 0, 0, 0, 0, 0, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100};
int A[25] = {1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};

vector<string> GenerateName(int);
vector<int> GenerateCard();

vector<string> name;

signed main() {
	set<string> res;
	while (name.size() <= 300) {
		string s;
		while (s.size() < 3) {
			s.push_back('a' + rand() % 26);
		}
		if (res.find(s) != res.end()) 
			continue;
		else {
			res.insert(s);
			name.push_back(s);
		}
	}
	
	for (int _ = 0; _ <= 20; ++ _) {
		debug(_)
		ofstream input(to_string(_) + ".in");
		
		if (_ == 0) {
			input << N[_] << endl;
			input << "Casino " << Q[_] << " 1000" << " 1" << endl;
			input << "Guest Kuo 1000 20000" << endl;
			input << "Win Kuo 100000" << endl;
			input << "Guest Kuo 30 15" << endl;
			input << "0" << endl;
			input << "Casino " << Q[_] << " 30" << " 2000000" << endl;
			input << "Guest Yang 1000 30" << endl;
			input << "Win Kuo 1000" << endl;
			input << "Win Yang 100000" << endl;
			input << "1" << endl;
			input << "9999 299" << endl; // guardskill bankerskill
			input << "4" << endl; // guests
			input << "JN 1000 10" << endl; // name money skill
			input << "Yao 100 300" << endl;
			input << "Yolo 10 100" << endl;
			input << "Genius 10 10000" << endl;
			input << "1" << endl; // rounds
			input << "JN 1000" << endl; // name betmoney
			input << "10 9" << endl; // cards
			input << "Yao 50" << endl;
			input << "11 10" << endl;
			input << "Yolo 10000" << endl;
			input << "1 1 1 1 2 2 2 2 3 3 3 3" << endl;
			input << "Genius 20000" << endl;
			input << "4 4 4 4 6" << endl;
			input << "9 9" << endl; // banker cards
			input.close();
			continue;
		}
		input << N[_] << endl;
		for (int ___ = 0; ___ < N[_]; ++ ___) {
			int U = rand() * 50;
			if (_ <= 15) U = 1000000000;
			input << "Casino " << Q[_] << " " << rand() % 10000 << " " << U << endl;
			
			vector<string> people;
			for (int __ = 0; __ < Q[_]; ++ __) {
				int op = rand() % 3;
				int id = rand() % 300;
				
				int neg = rand() % 200;
				if (neg <= 130) neg = 1;
				else neg = -1;

				if (op == 0) {
					input << "Guest " << name[id] << " " << rand() % 1000000 << " " << rand() % 100000 << endl;
					people.push_back(name[id]);
				}
				else if (op == 1 && people.size() != 0) {
					int kd = rand() % (people.size());
					input << "Win " << people[kd] << " " << neg * rand() % 30000 << endl;
				}
				else {
					input << "Win " << name[id] << " " << neg * rand() % 100000 << endl;
				}
			}
			
			if (A[_] == 1 && ___ == N[_] / 2) {
				input << A[_] << endl;
				A[_] -= 1;
				int N[25] = {3, 0, 0, 0, 0, 0, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100};
				int K[25] = {1, 0, 0, 0, 0, 0, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200};
		
				vector<string> names = GenerateName(N[_]);
		
				input << rand() << " " << rand() << endl;
				input << N[_] << endl;
				for (auto i : names)
					input << i << " " << rand() << " " << rand() << endl;
				input << K[_] << endl;
				while (K[_] --) {
					for (auto i : names) {
						input << i << " " << (int)(rand() / 1.5) << endl;
						vector<int> cards = GenerateCard();
						for (auto j : cards)
							input << j << " ";
						input << endl;
					}
					vector<int> cards = GenerateCard();
					for (auto i : cards)
						input << i << " ";
					input << endl;
				}
			}
			else input << 0 << endl;
		}
		input.close();
	}
	
	for (int _ = 0; _ <= 20; ++ _) {
		debug(_)
		ifstream input(to_string(_) + ".in");
		ofstream output(to_string(_) + ".out");
		
		int n, fee, q, U;
		string op;
		
		int income = 0;
		int pre_income = 0;
		vector<string> black;
		
		map<string, int> skill;
		map<string, int> money;
		set<string> list;
		set<string> casino;
		
		auto blacklist = [&](string s) -> void {
			if (casino.find(s) != casino.end())
				casino.erase(s);
			black.push_back(s);
			list.insert(s);
		};
		
		input >> n;
		while ( n -- ) {
			pre_income = income;
			input >> op >> q >> fee >> U;
			
			while ( q -- ) {
				input >> op;
				if (op == "Guest") {
					string s; int m, ski;
					input >> s >> m >> ski;
					if (list.find(s) != list.end()|| casino.find(s) != casino.end())
						continue;
					else if (m <= fee) {
						income += m;
						blacklist(s);
					}
					else {
						income += fee;
						money[s] = m - fee;
						skill[s] = ski;
						casino.insert(s);
					}
				}
				else if (op == "Win") {
					string s; int m;
					input >> s >> m;
					if (casino.find(s) == casino.end() || list.find(s) != list.end())
						continue;
					else if (m + money[s] <= 0) {
						income += money[s];
						blacklist(s);
					}
					else if (skill[s] * 2 < m) {
						income -= m;
						blacklist(s);
					}
					else {
						money[s] += m;
						income -= m;
					}
				}
			}
			if (income - pre_income >= U) {
				list.clear();
				black.clear();
				if (16 <= _) {
					debug("ok")
					debug(_)
				}
			}
			
			money.clear();
			skill.clear();
			casino.clear();
			
			int A;
			input >> A;
			if (A == 1) {
				#define F first
				#define S second
				
				pair<int, int> guard = {0, 0}, banker = {0, 0};
				int n, k;
				string name[1009];
				pair<int, int> player[1009];
				pair<int, int> bet[1009];
				bool invalid[1009] = {};
				
				input >> guard.S >> banker.S >> n;
				for (int i = 1; i <= n; ++ i)
					input >> name[i] >> player[i].F >> player[i].S;
				
				input >> k;
				while (k --) {
					for (int i = 1; i <= n; ++ i) {
						string a; bet[i].S = 0; 
						input >> a >> bet[i].F;
						string res = "";
						while (res.size() <= 0) 
							getline(input, res);
						stringstream ss(res);
						while (ss >> res) {
							int temp = 0;
							for (auto i : res)
								temp = temp * 10 + i - '0';
							bet[i].S += temp;
						}
					}
		
					int banker_card = 0;
					string res = "";
					while (res.size() <= 0)
						getline(input, res);
					stringstream ss(res);
					while (ss >> res) {
						int temp = 0;
						for (auto i : res)
							temp = temp * 10 + i - '0';
						banker_card += temp;
					}
					
					for (int i = 1; i <= n; ++ i) {
						if (invalid[i] == true)
							continue;
						if (bet[i].S <= 21 && (banker_card > 21 || bet[i].S > banker_card)) {
							int x = bet[i].F + (player[i].S < banker.S) * 10 * bet[i].S;
							if (bet[i].S == 21) x *= 2;
							player[i].F += x;
							banker.F -= x;
							
							if (player[i].S * 2 < x) {
								banker.F -= 100;
								guard.F += 100;
								if (player[i].S > guard.S) {
									guard.F -= player[i].S - guard.S;
									player[i].F += player[i].S - guard.S;
								}
								invalid[i] = true;
							}
						}
						else if (banker_card <= 21 && (bet[i].S > 21 || banker_card >= bet[i].S)) {
							banker.F += min(player[i].F, bet[i].F);
							player[i].F -= min(player[i].F, bet[i].F);
							
							
							if (player[i].F <= 0) {
								banker.F -= 100;
								guard.F += 100;
								invalid[i] = true;
							}
						}
					}
				}
				
				output << guard.F << " " << banker.F << endl;
				for (int i = 1; i <= n; ++ i)
					output << name[i] << " " << player[i].F << endl;
			}
		}
		input.close();
		
		output << income << endl;
		for (auto i : black)
			output << i << endl;
		debug(income)
	}
}


vector<string> GenerateName(int num) {
	set<string> res;
	while (res.size() < num) {
		string s = "";
		while (s.size() < 4) 
			s.push_back(rand() % 26 + 'a');
		res.insert(s);
	}
	return vector<string> (res.begin(), res.end());
}

vector<int> GenerateCard() {
	vector<int> res;
	int sum = 0;
	do {
		int a = rand() % 10 + 1;
		res.push_back(a);
		sum += res.back();
	}while (rand() % 4 != 0 && sum < 21);
	return res;
}
```
:::

:::spoiler main.cpp
```cpp=
#include <iostream>
#include <string>
#include "function.h"
using namespace std;

int n;
Casino casino = {};

void Twenty_Two();

int main() {
	ios::sync_with_stdio(0); cin.tie(0);
	
	cin >> n;
	for (int i = 0; i < n; ++ i) {
		string op;
		int q, fee, U;
		
		cin >> op >> q >> fee >> U;
		casino.Enterance(fee, U);
		for (int j = 0; j < q; ++ j) {
			cin >> op;
			if (op == "Guest") {
				string name; 
				int money, skill;
				cin >> name >> money >> skill;
				casino.GuestEnter(name, money, skill);
			} 
			else if (op == "Win") {
				string name;
				int money;
				cin >> name >> money;
				casino.Win(name, money);
			}
		}
		casino.EndDay();
		
		int A;
		cin >> A;
		if (A == 1) {
			Twenty_Two();
		}
	}
	casino.Result();
}

void Twenty_Two() {
	int guard_skill, banker_skill;
	cin >> guard_skill >> banker_skill;
	Human *guard = new Guard(guard_skill);
	Human *banker = new Banker(banker_skill);

	Human *player[1009];
	int n;
	cin >> n;
	for (int i = 1; i <= n; ++ i) {
		string name;
		int player_money, player_skill;
		cin >> name >> player_money >> player_skill;
		player[i] = new Player(name, player_money, player_skill);
	}

	int k;
	cin >> k;
	while (k--) {
		for (int i = 1; i <= n; ++ i) {
			player[i]->Bet();
			player[i]->Draw();
		}
		banker->Draw();
	
		for (int i = 1; i <= n; ++ i) {
			if (player[i]->Kicked())
				continue;
			
			if (banker->Win(player[i]) == 1) {
				player[i]->Pay(banker);
				if (player[i]->Bankrupt()) {
					banker->Pay(guard);
					guard->Kick(player[i], 0);
				}
			}
			else if (banker->Win(player[i]) == 0) {
				banker->Pay(player[i]);
				if (player[i]->Cheat(banker)) {
					banker->Pay(guard);
					guard->Kick(player[i], 1);
				}
			} // otherwise draw
		}
	}
	
	cout << guard->get_money() << " " << banker->get_money() << endl;
	for (int i = 1; i <= n; ++ i)
		cout << player[i]->name << " " << player[i]->get_money() << endl;
}
```
:::

:::spoiler function.h
```cpp=
#include <cstring>
#include <iostream>
using namespace std;

class Guest {
public:
	Guest();
	Guest(string s, int m, int ski);
	~Guest();
	string get_name();
	int get_money();
	int get_skill();
	void Win(int m);
	
private:
	string name;
	int money;
	int skill;
};

class Casino {
public:
	Casino();
	~Casino();
	void Enterance(int f, int u);
	void GuestEnter(string s, int m, int ski);
	void Win(string s, int m);
	void EndDay();
	void Result();
	
private:
	int fee, U;
	
	int guest_num;
	Guest* guest[1009];
	
	int income, pre_income;
	int list_num;
	string blacklist[1000009];
};

//////////////////////////////////////////////////////////////////////////////

class Human {
public:
	string name;
	int money;
	int skill;
	bool kicked;
	int cards;
	int bets;

	Human(string n, int m, int ski);
	
	virtual void Pay(Human *human) = 0;
	virtual void Bet() {}
	virtual void Draw() {}
	virtual bool Kicked() {}
	virtual int Win(Human *human) {}
	virtual bool Bankrupt() {}
	virtual void Kick(Human *human, int flag) {}
	virtual bool Cheat(Human *human) {}
	int get_money();
	~Human();
};

class Guard : public virtual Human {
public:
	Guard(int ski);
	void Pay(Human *human);
	void Kick(Human *human, int flag);
    ~Guard();
};

class Banker : public virtual Human {
public:
	Banker(int ski);
	void Pay(Human *human);
	int Win(Human *human);
	void Draw();
	~Banker();
};

class Player : public virtual Human {
public:
	Player(string name, int m, int ski);
	void Pay(Human *human);
	void Bet();
	void Draw();
	bool Kicked();
	bool Bankrupt();
	bool Cheat(Human *human);
	~Player();
};
```
:::

::: spoiler solution
```cpp=
#include <bits/stdc++.h>
using namespace std;

class Guest {
public:
	Guest();
	Guest(string s, int m, int ski);
	~Guest();
	string get_name();
	int get_money();
	int get_skill();
	void Win(int m);
	
private:
	string name;
	int money;
	int skill;
};

class Casino {
public:
	Casino();
	~Casino();
	void Enterance(int f, int u);
	void GuestEnter(string s, int m, int ski);
	void Win(string s, int m);
	void EndDay();
	void Result();
	
private:
	int fee, U;
	
	int guest_num;
	Guest* guest[1009];
	
	int last_income;
	int income, pre_income;
	int list_num;
	string blacklist[1000009];
};

//////////////////////////////////////////////////////////////////////////////

class Human {
public:
	string name;
	int money;
	int skill;
	bool kicked;
	int cards;
	int bets;

	Human(string n, int m, int ski);
	
	virtual void Pay(Human *human) = 0;
	virtual void Bet() {}
	virtual void Draw() {}
	virtual bool Kicked() {}
	virtual int Win(Human *human) {}
	virtual bool Bankrupt() {}
	virtual void Kick(Human *human, int flag) {}
	virtual bool Cheat(Human *human) {}
	int get_money();
	~Human();
};

class Guard : public virtual Human {
public:
	Guard(int ski);
	void Pay(Human *human);
	void Kick(Human *human, int flag);
};

class Banker : public virtual Human {
public:
	Banker(int ski);
	void Pay(Human *human);
	int Win(Human *human);
	void Draw();
	~Banker();
};

class Player : public virtual Human {
public:
	Player(string name, int m, int ski);
	void Pay(Human *human);
	void Bet();
	void Draw();
	bool Kicked();
	bool Bankrupt();
	bool Cheat(Human *human);
	~Player();
};

Guest::Guest() {}
Guest::Guest(string s, int m, int ski) {
	name = s;
	money = m;
	skill = ski;
}
string Guest::get_name() {
	return name;
}
int Guest::get_money() {
	return money;
}
int Guest::get_skill() {
	return skill;
}
void Guest::Win(int m) {
	money += m;
}
Guest::~Guest() {}

Casino::Casino() {
	guest_num = 0;
	list_num = 0;
	guest = new Guest [1009];
}
void Casino::Enterance(int f, int u) {
	fee = f;
	U = u;
}
void Casino::GuestEnter(string s, int m, int ski) {
	for (int i = 0; i < list_num; ++ i)
		if (blacklist[i] == s)
			return;
	for (int i = 0; i < guest_num; ++ i)
		if (guest[i].get_name() == s)
			return;
	
	if (m <= fee) {
		income += m;
		blacklist[list_num ++] = s;
	}
	else {
		income += fee;
		guest[guest_num ++] = Guest(s, m - fee, ski);
	}
}
void Casino::Win(string s, int m) {
	for (int i = 0; i < list_num; ++ i)
		if (blacklist[i] == s)
			return;
	
	int id;
	for (id = 0; id < guest_num; ++ id)
		if (guest[id].get_name() == s)
			break;
	if (id == guest_num)
		return;

	if (guest[id].get_money() + m <= 0) {
		income += guest[id].get_money();
		blacklist[list_num ++] = s;
	}
	else if (guest[id].get_skill() * 2 < m) {
		income -= m;
		blacklist[list_num ++] = s;
	}
	else {
		income -= m;
		guest[id].Win(m);
	}
}
void Casino::EndDay() {
	if (income - pre_income >= U) {
		list_num = 0;
	}
	pre_income = income;
	guest_num = 0;
}
void Casino::Result() {
	cout << income << endl;
	for (int i = 0; i < list_num; ++ i)
		cout << blacklist[i] << endl;
}
Casino::~Casino() {}

//////////////////////////////////////////////////////////////////////////////

Human::Human(string n, int m, int ski) {
	name = n;
	money = m;
	skill = ski;
	
	kicked = false;
	cards = 0;
}

int Human::get_money() {
	return this->money;
}

/////////////////////////////////////////////

Guard::Guard(int ski) : Human("guard", 0, ski) {}
void Guard::Pay(Human *human) {
	human->money += human->skill - this->skill;
	this->money -= human->skill - this->skill;
}
void Guard::Kick(Human *human, int flag) {
	if (flag == 1 && this->skill < human->skill) {
		Pay(human);
	}
	human->kicked = true;
}

/////////////////////////////////////////////

Banker::Banker(int ski) : Human("banker", 0, ski) {}
void Banker::Pay(Human *human) {
	if (human->name == "guard") {
		human->money += 100;
		this->money -= 100;
	}
	else {
		int x = (human->bets + (human->skill < this->skill) * human->cards * 10) * (1 + (human->cards == 21));
		human->money += x;
		this->money -= x;
	}
}
int Banker::Win(Human *human) {
	if (this->cards > 21 && human->cards > 21)
		return 2;
	if (this->cards <= 21 && (human->cards > 21 || human->cards <= this->cards))
		return 1;
	return 0;
}
void Banker::Draw() {
	this->cards = 0;
	
	string res = "";
	while (res.size() <= 0)
		getline(cin, res);
	stringstream ss(res);
	
	while (ss >> res) {
		int temp = 0;
		for (auto i : res)
			temp = temp * 10 + i - '0';
		this->cards += temp;
	}
}

/////////////////////////////////////////////

Player::Player(string name, int m, int ski) : Human(name, m, ski) {}
void Player::Pay(Human *human) {
	human->money += min(this->bets, this->money);
	this->money -= min(this->bets, this->money);
}
void Player::Bet() {
	string a;
	cin >> a >> this->bets;
}
void Player::Draw() {
	this->cards = 0;
		
	string res = "";
	while (res.size() <= 0)
		getline(cin, res);
	stringstream ss(res);
	
	while (ss >> res) {
		int temp = 0;
		for (auto i : res)
			temp = temp * 10 + i - '0';
		this->cards += temp;
	}
}
bool Player::Kicked() {
	return this->kicked;
}
bool Player::Bankrupt() {
	return (this->money <= 0);
}
bool Player::Cheat(Human *human) {
	int x = (this->bets + (this->skill < human->skill) * this->cards * 10) * (1 + (this->cards == 21));
	return (this->skill * 2 < x);
}
```
:::

## 13222 - Sum of Maximum

:::spoiler input
```cpp=
#include <bits/stdc++.h>
using namespace std;

#define int long long
#define IOS ios::sync_with_stdio(0); cin.tie(0);
#define endl '\n'

int N[7] = {5, 100, 100, 5000, 5000, 1000000, 1000000};

signed main() {
	
	for (int _ = 0; _ <= 6; ++ _) {
		ofstream input(to_string(_) + ".in");
		if (_ == 0) {
			input << "5" << endl;
			input << "7 8 4 6 3" << endl;
			input.close();
		}

		random_device rd;
		default_random_engine gen = default_random_engine(rd());
		uniform_int_distribution<int> dis(-1000000 * (_ % 2), 1000000);
		auto random = bind(dis, gen);
		
		input << N[_] << endl;
		for (int i = 1; i <= N[_]; ++ i)
			input << random() << " ";
		input << endl;
		
		input.close();
	}
	
	for (int _ = 0; _ <= 6; ++ _) {
		ifstream input(to_string(_) + ".in");
		
		int n;
		input >> n;
		if (_ <= 2) 
			assert(n <= 100);
		else if (_ <= 4)
			assert(n <= 5000);
		else 
			assert(n <= 1000000);
		
		for (int i = 1; i <= n; ++ i) {
			int a;
			input >> a;
			assert(abs(a) <= 1000000);
		}
		
		input.close();
	}
}
```
:::

::: spoiler output
```cpp=
#include <bits/stdc++.h>
using namespace std;

#define int long long
#define IOS ios::sync_with_stdio(0); cin.tie(0);
#define endl '\n'
#define mk make_pair
#define F first
#define S second

using pii = pair<int, int>;

signed main() { IOS
	for (int _ = 0; _ <= 6; ++ _) {
		ifstream input(to_string(_) + ".in");
		ofstream output(to_string(_) + ".out");
		
		int n;
		vector<pii> t;
		int res = 0, ans = 0;
	    
		input >> n;
	    for(int i = 1; i <= n; ++ i) {
	        
			int a; input >> a;
	        while(!t.empty() && t.back().F < a)
	        {
	            auto p = t.back(); t.pop_back();
	            if(!t.empty()) 
					res -= (p.S - t.back().S) * p.F;
	            else 
					res -= p.S * p.F;
	        }
			
			if(!t.empty()) 
				res += (i - t.back().S) * a;
	        else 
				res += i * a;
			
			ans += res;
			t.push_back(mk(a, i));
	    }
	    cout << ans << endl;
	    output << ans << endl;	
	}

	
} 
```
:::

:::spoiler solution
```cpp=
#include <bits/stdc++.h>
using namespace std;

#define int long long
#define IOS ios::sync_with_stdio(0); cin.tie(0);
#define endl '\n'
#define pb push_back
#define sz(v) (int)(v).size()
#define mk make_pair
#define F first
#define S second

using pii = pair<int, int>;

signed main() { IOS
	int n;
	cin >> n;
	
	vector<pii> v;
	int res = 0, ans = 0;
	
	for (int i = 1; i <= n; ++ i) {
		int a; cin >> a;
		while (sz(v) && v.back().F < a) {
			auto p = v.back(); v.pop_back();
			
			if (sz(v)) res -= (p.S - v.back().S) * p.F;
			else res -= p.S * p.F;
		}
		
		if (sz(v)) res += (i - v.back().S) * a;
		else res += i * a;
		
		ans += res;
		v.pb(mk(a, i));
	}
	cout << ans << endl;
}
```
:::

## 13223 - Maximum of Interval
:::spoiler input
```cpp=
#include <bits/stdc++.h>
using namespace std;

#define int long long
#define IOS ios::sync_with_stdio(0); cin.tie(0);
#define endl '\n'

int N[7] = {5, 100, 100, 5000, 5000, 1000000, 1000000};

signed main() {
	
	for (int _ = 0; _ <= 6; ++ _) {
		ofstream input(to_string(_) + ".in");
		if (_ == 0) {
			input << "5 3" << endl;
			input << "7 8 4 6 3" << endl;
			input.close();
		}

		random_device rd;
		default_random_engine gen = default_random_engine(rd());
		uniform_int_distribution<int> dis(-1000000 * (_ % 2), 1000000);
		auto random = bind(dis, gen);
		
		input << N[_] << " " << N[_] / 2 << endl;
		for (int i = 1; i <= N[_]; ++ i)
			input << random() << " ";
		input << endl;
		
		input.close();
	}
	
	for (int _ = 0; _ <= 6; ++ _) {
		ifstream input(to_string(_) + ".in");
		
		int n, l;
		input >> n >> l;
		
		if (_ <= 2) 
			assert(n <= 100);
		else if (_ <= 4)
			assert(n <= 5000);
		else 
			assert(n <= 1000000);
		assert(l <= n);
		
		for (int i = 1; i <= n; ++ i) {
			int a;
			input >> a;
			assert(abs(a) <= 1000000);
		}
		
		while (input >> n) {
			return -1;
		}
		
		input.close();
	}
}
```
:::

:::spoiler output
```cpp=
#include <bits/stdc++.h>
using namespace std;

#define int long long
#define IOS ios::sync_with_stdio(0); cin.tie(0);
#define endl '\n'
#define sz(v) (int)(v).size()
#define mk make_pair
#define F first
#define S second

using pii = pair<int, int>;

signed main() { IOS
	for (int _ = 0; _ <= 6; ++ _) {
		ifstream input(to_string(_) + ".in");
		ofstream output(to_string(_) + ".out");
		
		int n, L;
		input >> n >> L;
		
		deque<pii> d;
		for (int i = 1; i <= L - 1; ++ i) {
			int a; input >> a;
			while (sz(d) && d.back().F <= a) d.pop_back();
			d.push_back(mk(a, i));
		}
		
		for (int i = 1; i <= n - L + 1; ++ i) {
			if (d.front().S < i) d.pop_front();
			int a; input >> a;
			while (sz(d) && d.back().F <= a) d.pop_back();
			d.push_back(mk(a, i));
			output << d.front().F << " ";
		}
		output << endl;
		
		input.close();
		output.close();
	}
	
	for (int _ = 0; _ <= 6; ++ _) {
		ifstream input(to_string(_) + ".in");
		int n, L;
		input >> n >> L;
		input.close();
		
		ifstream output(to_string(_) + ".out");
		for (int i = 1; i <= n - L + 1; ++ i) {
			int a; 
			output >> a;
		}
		while (output >> n) {
			return -1;
		}
		output.close();
	}

	
} 
```
:::

::: spoiler solution
```cpp=
#include <bits/stdc++.h>
using namespace std;

#define int long long
#define IOS ios::sync_with_stdio(0); cin.tie(0);
#define endl '\n'
#define pb push_back
#define sz(v) (int)(v).size()
#define mk make_pair
#define F first
#define S second

using pii = pair<int, int>;

signed main() { IOS
	int n, L;
	cin >> n >> L;
	
	deque<pii> d;
	
	for (int i = 1; i <= L - 1; ++ i) {
		int a; cin >> a;
		while (sz(d) && d.back().F <= a) d.pop_back();
		d.push_back(mk(a, i));
	}
	for (int i = 1; i <= n - L + 1; ++ i) {
		if (d.front().S < i) d.pop_front();
		int a; cin >> a;
		while (sz(d) && d.back().F <= a) d.pop_back();
		d.push_back(mk(a, i));
		cout << d.front().F << " ";
	}
	cout << endl;
}
```
:::

## 13227 - Yu-Gi-Oh! 
::: spoiler input
```cpp=
#include <bits/stdc++.h>
using namespace std;

#define int long long
#define IOS ios::sync_with_stdio(0); cin.tie(0);
#define endl '\n'
#define all(v) (v).begin(),(v).end()
#define sz(v) (int)(v).size()

int N[7] = {5, 100, 100, 3000, 3000, 200000, 200000};

signed main() {
	for (int _ = 0; _ <= 6; ++ _) {
		ofstream input(to_string(_) + ".in");
		
		int right = (right <= 2) ? 10000000 : ((right <= 4) ? 100000000000000LL : 1000000000000000000LL);
		
		random_device rd;
		default_random_engine gen = default_random_engine(rd());
		uniform_int_distribution<int> dis(0LL, right);
		auto random = bind(dis, gen);
		
		if (_ == 0) {
			input << 5 << endl;
			input << 2 << endl;
			input << 1 << endl;
			input << 1 << endl;
			input << 2 << endl;
			input << 2 << endl;
			input.close();
			continue;
		}
		
		set<int> s;
		while (sz(s) < sqrt(N[_]) / 2) s.insert(random());
		vector<int> v(s.begin(), s.end());
		random_shuffle(all(v));
		
		input << N[_] << endl;
		for (int i = 1; i <= N[_]; ++ i)
			input << v[random() % sz(v)] << endl;
			
		input.close();
	}
}
```
:::

::: spoiler output
```cpp=
#include <bits/stdc++.h>
using namespace std;

#define int long long
#define IOS ios::sync_with_stdio(0); cin.tie(0);
#define endl '\n'
#define all(v) (v).begin(),(v).end()
#define sz(v) (int)(v).size()

signed main() {
	for (int _ = 0; _ <= 6; ++ _) {
		ifstream input(to_string(_) + ".in");
		ofstream output(to_string(_) + ".out");
		
		int n;
		map<int, int> m;
		int res = -1;
		
		input >> n;
		for (int i = 1; i <= n; ++ i) {
			int a;
			input >> a;
			
			m[a] += 1;
			if (m[a] > m[res] || (m[a] == m[res] && a > res))
				res = a;
			output << res << endl;
		}
		
		input.close();
		output.close();
	}
}
```
:::

::: spoiler solution
```cpp=
#include <bits/stdc++.h>
using namespace std;

int main() {
	int n;
	long long res;
	map<long long, int> m;
	
	cin >> n;
	for (int i = 1; i <= n; ++ i) {
		long long a; 
		cin >> a;
		++ m[a];
		if (m[res] < m[a] || (m[a] == m[res] && a > res))
			res = a;
		cout << res << endl;
	}
}
```
:::